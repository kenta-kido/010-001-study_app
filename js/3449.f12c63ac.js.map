{"version":3,"file":"js/3449.f12c63ac.js","mappings":"y2BACEA,EAAAA,EAAAA,IAihCM,MAjhCNC,EAihCM,C,glEAh8BJC,EAAAA,EAAAA,IAYM,MAZNC,EAYM,EAXJD,EAAAA,EAAAA,IAIE,OAHCE,KAAKC,EAAAA,EAAAA,IAAAC,GACNC,IAAI,oEACJC,MAAM,4B,uBAERN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,wBAAuB,uEAEhC,I,aACAN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,cAAa,yCAEtB,M,o/LA4NFN,EAAAA,EAAAA,IAYM,MAZNO,EAYM,EAXJP,EAAAA,EAAAA,IAIE,OAHCE,KAAKC,EAAAA,EAAAA,IAAAK,GACNH,IAAI,iEACJC,MAAM,4B,uBAERN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,wBAAuB,oEAEhC,I,aACAN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,cAAa,4CAEtB,M,2gUAkVFN,EAAAA,EAAAA,IAIM,MAJNS,EAIM,EAHJT,EAAAA,EAAAA,IAAgG,OAA1FE,KAAKC,EAAAA,EAAAA,IAAAO,GAAgBL,IAAI,8BAA8BC,MAAM,4B,uBACnEN,EAAAA,EAAAA,IAA+D,KAA5DM,MAAM,wBAAuB,+BAA2B,I,aAC3DN,EAAAA,EAAAA,IAA4C,KAAzCM,MAAM,cAAa,sBAAkB,OAI1CN,EAAAA,EAAAA,IAIM,MAJNW,EAIM,EAHJX,EAAAA,EAAAA,IAAoG,OAA9FE,KAAKC,EAAAA,EAAAA,IAAAS,GAAkBP,IAAI,gCAAgCC,MAAM,4B,uBACvEN,EAAAA,EAAAA,IAAiE,KAA9DM,MAAM,wBAAuB,iCAA6B,I,aAC7DN,EAAAA,EAAAA,IAA4C,KAAzCM,MAAM,cAAa,sBAAkB,M,48DA8D1CN,EAAAA,EAAAA,IAIM,MAJNa,EAIM,EAHJb,EAAAA,EAAAA,IAAgG,OAA1FE,KAAKC,EAAAA,EAAAA,IAAAW,GAAgBT,IAAI,8BAA8BC,MAAM,4B,uBACnEN,EAAAA,EAAAA,IAA+D,KAA5DM,MAAM,wBAAuB,+BAA2B,I,aAC3DN,EAAAA,EAAAA,IAA4C,KAAzCM,MAAM,cAAa,sBAAkB,OAI1CN,EAAAA,EAAAA,IAIM,MAJNe,EAIM,EAHJf,EAAAA,EAAAA,IAAoG,OAA9FE,KAAKC,EAAAA,EAAAA,IAAAa,GAAkBX,IAAI,gCAAgCC,MAAM,4B,yBACvEN,EAAAA,EAAAA,IAAiE,KAA9DM,MAAM,wBAAuB,iCAA6B,I,eAC7DN,EAAAA,EAAAA,IAA4C,KAAzCM,MAAM,cAAa,sBAAkB,M,qyMAmP1CN,EAAAA,EAAAA,IAYM,MAZNiB,EAYM,EAXJjB,EAAAA,EAAAA,IAIE,OAHCE,KAAKC,EAAAA,EAAAA,IAAAe,GACNb,IAAI,8BACJC,MAAM,4B,yBAERN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,wBAAuB,iCAEhC,I,eACAN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,cAAa,wBAEtB,OAIFN,EAAAA,EAAAA,IAYM,MAZNmB,EAYM,EAXJnB,EAAAA,EAAAA,IAIE,OAHCE,KAAKC,EAAAA,EAAAA,IAAAiB,GACNf,IAAI,oCACJC,MAAM,4B,yBAERN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,wBAAuB,qEAEhC,I,eACAN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,cAAa,oCAEtB,M,urBCl/BN,MAAMe,EAAc,EAEpB,O","sources":["webpack://study-site/./src/views/lecture/lecture04/chapter03/chapter03_41.vue","webpack://study-site/./src/views/lecture/lecture04/chapter03/chapter03_41.vue?a977"],"sourcesContent":["<template>\r\n  <div class=\"container my-4\">\r\n    <h3 class=\"mb-4\">3.4.1 Building a Reliable Data Transfer Protocol</h3>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          We now step through a series of protocols, each one becoming more complex,\r\n          arriving at a flawless, reliable data transfer protocol.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          ここでは、一連のプロトコルを段階的に見ていきます。それぞれが徐々に複雑になり、最終的には完全な信頼性を備えたデータ転送プロトコルに到達します。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 中タイトル -->\r\n    <div class=\"row mb-4\">\r\n      <div class=\"col-12\">\r\n        <p class=\"fw-bold\" style=\"color: #004085;\">\r\n          Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- rdt1.0の導入とFSMについて -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          We first consider the simplest case, in which the underlying channel is completely reliable.\r\n          The protocol itself, which we’ll call <code>rdt1.0</code>, is trivial.\r\n          The finite-state machine (FSM) definitions for the <code>rdt1.0</code> sender and receiver are shown in Figure 3.9.\r\n        </p>\r\n        <p>\r\n          The FSM in Figure 3.9(a) defines the operation of the sender, while Figure 3.9(b) defines the receiver.\r\n          There are separate FSMs for the sender and for the receiver.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          まずは最も単純なケースを考えます。下位チャネルが完全に信頼できる場合です。\r\n          このときのプロトコル <code>rdt1.0</code> は非常に単純です。\r\n          その送信側・受信側の有限状態機械（FSM）は図3.9に示されています。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          図3.9(a) は送信側の、(b) は受信側のFSMを表します。\r\n          送信側と受信側にはそれぞれ独立したFSMがあります。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- FSMの動作について -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Each FSM in Figure 3.9 has just one state. Transitions (arrows) show the response to events.\r\n          The event is labeled above the horizontal line; the resulting action is below the line.\r\n          If no event or action occurs, we denote this with Λ.\r\n        </p>\r\n        <p>\r\n          The initial state is indicated by a dashed arrow.\r\n          Though these FSMs have only one state, upcoming ones will have more, so identifying the initial state becomes important.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          図3.9の各FSMは1つの状態しか持ちません。\r\n          状態遷移（矢印）は、イベントに対する反応を示します。\r\n          水平線の上にはイベント、下にはアクションが書かれています。\r\n          イベントまたはアクションが無い場合は、明示的に <code>Λ</code> を使って示します。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          初期状態は破線の矢印で示されます。\r\n          本図では状態は1つのみですが、今後のFSMでは複数の状態を持つようになるため、\r\n          初期状態の明示が重要になります。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 図3.9 表示 -->\r\n    <div class=\"text-center my-4\">\r\n      <img\r\n        :src=\"imgUrl9\"\r\n        alt=\"Figure 3.9 - rdt1.0: A protocol for a completely reliable channel\"\r\n        class=\"img-fluid rounded border\"\r\n      />\r\n      <p class=\"text-muted mt-2 mb-0\">\r\n        Figure 3.9 — rdt1.0: A protocol for a completely reliable channel\r\n      </p>\r\n      <p class=\"text-muted\">\r\n        図3.9 — rdt1.0：完全に信頼できるチャネルに対するプロトコル\r\n      </p>\r\n    </div>\r\n\r\n    <!-- 送信側の動作 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          The sending side of rdt simply accepts data via the <code>rdt_send(data)</code> event,\r\n          creates a packet with <code>make_pkt(data)</code>, and sends it.\r\n          In practice, <code>rdt_send()</code> would be called by an upper-layer app.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          <code>rdt</code> の送信側は、<code>rdt_send(data)</code> イベントによって上位層からデータを受け取り、\r\n          <code>make_pkt(data)</code> でパケットを作成し、チャネルに送信します。\r\n          実際にはこれは上位アプリケーションからの関数呼び出しになります。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 受信側の動作 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          The receiving side gets a packet via <code>rdt_rcv(packet)</code>,\r\n          extracts data with <code>extract(packet, data)</code>,\r\n          and delivers it via <code>deliver_data(data)</code>.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          受信側は <code>rdt_rcv(packet)</code> によりパケットを受け取り、\r\n          <code>extract(packet, data)</code> でデータを取り出し、\r\n          <code>deliver_data(data)</code> を使って上位層へ渡します。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- パケットとフィードバックの必要性なし -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          In this protocol, a data unit and a packet are equivalent.\r\n          All packets flow from sender to receiver; the receiver gives no feedback due to perfect reliability.\r\n        </p>\r\n        <p>\r\n          It’s also assumed the receiver can always keep up with the sender, so no flow control is needed.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          このプロトコルでは、データ単位とパケットは同一です。\r\n          パケットはすべて送信側から受信側へ一方向に流れます。\r\n          チャネルが完全に信頼できるため、受信側からのフィードバックは不要です。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          また、受信側は常に送信側に追いつけると仮定されているため、\r\n          フロー制御の必要もありません。\r\n        </p>\r\n      </div>\r\n    </div>\r\n        <!-- 中タイトル -->\r\n    <div class=\"row mb-4\">\r\n      <div class=\"col-12\">\r\n        <p class=\"fw-bold\" style=\"color: #004085;\">\r\n          Reliable Data Transfer over a Channel with Bit Errors: rdt2.0\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 説明1：ビット誤りを含むチャネル -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          A more realistic model of the underlying channel is one in which bits in a packet may\r\n          be corrupted. Such bit errors typically occur in the physical components of a network\r\n          as a packet is transmitted, propagates, or is buffered.\r\n        </p>\r\n        <p>\r\n          We’ll continue to assume for now that all transmitted packets are received (although\r\n          possibly corrupted) in order.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          より現実的なチャネルモデルでは、パケット内のビットが破損する可能性があります。\r\n          このようなビットエラーは、パケットが送信、伝搬、あるいはバッファリングされる過程で、\r\n          ネットワークの物理的な構成要素に起因して発生します。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          今のところ、すべての送信パケットは順番通りに受信される（ただしビットが破損しているかもしれない）\r\n          という前提を続けます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 説明2：人間のやり取りになぞらえた説明 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Before developing a protocol for such a channel, consider how people handle this situation.\r\n          For example, during a phone call, if someone mishears a sentence, they ask to repeat it.\r\n          A typical exchange involves positive (“OK”) and negative (“Please repeat”) acknowledgments.\r\n        </p>\r\n        <p>\r\n          These control messages allow the receiver to inform the sender about correct or\r\n          incorrect reception. Protocols based on such retransmissions are called\r\n          <strong>ARQ (Automatic Repeat reQuest)</strong> protocols.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          このようなチャネル向けのプロトコルを開発する前に、\r\n          人間がどのようにこの状況に対処するかを考えてみましょう。\r\n          たとえば電話でメッセージを伝える際、聞き取れなかった部分は「もう一度言ってください」と求めます。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          このように「OK」や「繰り返してください」といった確認応答を使うことにより、\r\n          受信者は何が正しく受信されたか、何が誤って受信されたかを送信者に伝えることができます。\r\n          コンピュータネットワークでは、これに基づいたプロトコルを\r\n          <strong>ARQ（自動再送要求）プロトコル</strong>と呼びます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 説明3：ARQに必要な3つの機能 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Fundamentally, ARQ protocols require three additional capabilities:\r\n        </p>\r\n      </div>\r\n      \r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          ARQプロトコルには、以下の3つの機能が必要です：\r\n        </p>\r\n      </div>\r\n    </div>\r\n    <!-- Error Detection -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          • <strong>Error detection.</strong> First, a mechanism is needed to allow the receiver to detect when\r\n          bit errors have occurred. Recall from the previous section that UDP uses the Internet\r\n          checksum field for exactly this purpose. In Chapter 6, we’ll examine error-detection\r\n          and -correction techniques in greater detail; these techniques allow the\r\n          receiver to detect and possibly correct packet bit errors.\r\n        </p>\r\n        <p>\r\n          For now, we need only know that these techniques require that extra bits (beyond the\r\n          bits of original data to be transferred) be sent from the sender to the receiver; these bits\r\n          will be gathered into the packet checksum field of the rdt2.0 data packet.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          • <strong>エラー検出：</strong> まず、受信側がビットエラーの発生を検出できる仕組みが必要です。\r\n          前節で説明したように、UDP はまさにこの目的のためにインターネットチェックサムフィールドを利用しています。\r\n          第6章では、誤り検出・訂正技術についてさらに詳しく取り上げます。\r\n          これらの技術により、受信側はパケットのビット誤りを検出し、場合によっては訂正することができます。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          現時点では、こうした技術には送信元から受信先に、元のデータビットに加えて余分なビット（冗長ビット）を送る必要があるという点だけを理解しておけば十分です。\r\n          これらのビットは <code>rdt2.0</code> データパケットのチェックサムフィールドにまとめられます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Receiver Feedback -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          • <strong>Receiver feedback.</strong> Since the sender and receiver are typically executing on different\r\n          end systems, possibly separated by thousands of miles, the only way for\r\n          the sender to learn of the receiver’s view of the world (in this case, whether or not\r\n          a packet was received correctly) is for the receiver to provide explicit feedback\r\n          to the sender.\r\n        </p>\r\n        <p>\r\n          The positive (ACK) and negative (NAK) acknowledgment replies\r\n          in the message-dictation scenario are examples of such feedback. Our rdt2.0\r\n          protocol will similarly send ACK and NAK packets back from the receiver to\r\n          the sender. In principle, these packets need only be one bit long; for example, a 0\r\n          value could indicate a NAK and a value of 1 could indicate an ACK.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          • <strong>受信側からのフィードバック：</strong>\r\n          送信側と受信側は通常、異なるエンドシステム上で動作しており、物理的に何千マイルも離れている可能性があります。\r\n          したがって、送信側が受信側の状態（パケットが正しく受信されたかどうか）を知る唯一の方法は、\r\n          受信側が送信側に明示的なフィードバックを返すことです。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          音声でのメッセージ伝達の例で見たように、「OK（ACK）」や「もう一度言ってください（NAK）」といった応答は、\r\n          こうしたフィードバックの例です。\r\n          <code>rdt2.0</code> プロトコルでも同様に、ACK や NAK パケットを受信側から送信側へ返します。\r\n          理論上、これらのパケットは1ビットの長さで十分です。例えば、0 が NAK、1 が ACK を意味するように定義できます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Retransmission -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          • <strong>Retransmission.</strong> A packet that is received in error at the receiver will be retransmitted\r\n          by the sender.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          • <strong>再送：</strong>\r\n          受信側でエラーが検出されたパケットは、送信側によって再送されます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n    <!-- 図3.10 -->\r\n    <div class=\"text-center my-4\">\r\n      <img\r\n        :src=\"imgUrl10\"\r\n        alt=\"Figure 3.10 - rdt2.0: A protocol for a channel with bit errors\"\r\n        class=\"img-fluid rounded border\"\r\n      />\r\n      <p class=\"text-muted mt-2 mb-0\">\r\n        Figure 3.10 — rdt2.0: A protocol for a channel with bit errors\r\n      </p>\r\n      <p class=\"text-muted\">\r\n        図3.10 — rdt2.0：ビットエラーのあるチャネルに対応するプロトコル\r\n      </p>\r\n    </div>\r\n\r\n\r\n    <!-- 送信側の2状態 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          The send side of rdt2.0 has two states. In the leftmost state, the send-side\r\n          protocol is waiting for data to be passed down from the upper layer. When the\r\n          <code>rdt_send(data)</code> event occurs, the sender will create a packet (<code>sndpkt</code>) containing\r\n          the data to be sent, along with a packet checksum (for example, as discussed\r\n          in Section 3.3.2 for the case of a UDP segment), and then send the packet via the\r\n          <code>udt_send(sndpkt)</code> operation.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          <code>rdt2.0</code> の送信側には 2 つの状態があります。左側の状態では、送信側プロトコルは上位層からデータが渡されるのを待っています。\r\n          <code>rdt_send(data)</code> イベントが発生すると、送信側は送信すべきデータを含むパケット <code>sndpkt</code> を作成し、\r\n          （たとえばセクション 3.3.2 で説明した UDP セグメントのように）チェックサムも含めて、\r\n          <code>udt_send(sndpkt)</code> 操作を通じてパケットをチャネルへ送信します。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- ACK/NAK を待つ状態 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          In the rightmost state, the sender protocol is waiting\r\n          for an ACK or a NAK packet from the receiver. If an ACK packet is received\r\n          (the notation <code>rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)</code> in Figure 3.10 corresponds\r\n          to this event), the sender knows that the most recently transmitted packet\r\n          has been received correctly and thus the protocol returns to the state of waiting for\r\n          data from the upper layer.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          右側の状態では、送信側プロトコルは受信側からの ACK または NAK パケットを待っています。\r\n          ACK パケットが受信されると（図 3.10 の <code>rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)</code> に対応）、\r\n          送信側は直前に送信したパケットが正しく受信されたことを認識し、\r\n          再び上位層からのデータ受信を待つ状態に戻ります。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- NAK 受信と再送 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          If a NAK is received, the protocol retransmits the last\r\n          packet and waits for an ACK or NAK to be returned by the receiver in response to\r\n          the retransmitted data packet.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          もし NAK が受信された場合、プロトコルは直前のパケットを再送し、\r\n          それに対する ACK または NAK を受信側が返してくるのを待ちます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Stop-and-waitの説明 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          It is important to note that when the sender is in the\r\n          wait-for-ACK-or-NAK state, it cannot get more data from the upper layer; that is, the\r\n          <code>rdt_send()</code> event can not occur; that will happen only after the sender receives\r\n          an ACK and leaves this state.\r\n        </p>\r\n        <p>\r\n          Thus, the sender will not send a new piece of data until\r\n          it is sure that the receiver has correctly received the current packet. Because of this\r\n          behavior, protocols such as rdt2.0 are known as <strong>stop-and-wait protocols</strong>.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          重要な点として、送信側が ACK または NAK を待つ状態にある間は、\r\n          上位層から新たなデータを受け取ることができません。\r\n          つまり、<code>rdt_send()</code> イベントはこの状態では発生せず、\r\n          ACK を受信してこの状態を抜けた後にのみ発生可能になります。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          したがって、受信側が現在のパケットを正しく受信したことを確認するまで、\r\n          送信側は新しいデータを送信しません。\r\n          このような動作のため、<code>rdt2.0</code> のようなプロトコルは<strong>ストップアンドウェイト（stop-and-wait）プロトコル</strong>と呼ばれます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 受信側 FSM の説明 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          The receiver-side FSM for rdt2.0 still has a single state. On packet arrival,\r\n          the receiver replies with either an ACK or a NAK, depending on whether or not the\r\n          received packet is corrupted.\r\n        </p>\r\n        <p>\r\n          In Figure 3.10, the notation <code>rdt_rcv(rcvpkt) &amp;&amp;\r\n          corrupt(rcvpkt)</code> corresponds to the event in which a packet is received and is\r\n          found to be in error.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          <code>rdt2.0</code> の受信側 FSM は引き続き 1 つの状態のみを持ちます。\r\n          パケットを受信すると、エラーの有無に応じて ACK または NAK を返します。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          図 3.10 の <code>rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt)</code> という記述は、\r\n          パケットが受信され、エラーが検出された場合のイベントを表しています。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n\r\n    <!-- 欠陥の説明 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Protocol rdt2.0 may look as if it works but, unfortunately, it has a fatal flaw.\r\n          In particular, we haven’t accounted for the possibility that the ACK or NAK packet\r\n          could be corrupted! (Before proceeding on, you should think about how this problem\r\n          may be fixed.) Unfortunately, our slight oversight is not as innocuous as it may\r\n          seem.\r\n        </p>\r\n        <p>\r\n          Minimally, we will need to add checksum bits to ACK/NAK packets in order\r\n          to detect such errors. The more difficult question is how the protocol should recover\r\n          from errors in ACK or NAK packets. The difficulty here is that if an ACK or NAK\r\n          is corrupted, the sender has no way of knowing whether or not the receiver has correctly\r\n          received the last piece of transmitted data.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          rdt2.0 プロトコルは一見すると正しく動作するように見えますが、実は致命的な欠陥があります。\r\n          特に、ACK または NAK パケット自体が破損する可能性を考慮していません。\r\n          （先に進む前に、この問題をどのように修正するかを少し考えてみてください。）\r\n          残念ながら、この見落としはそれほど軽微なものではありません。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          最低限でも、ACK／NAK パケットにチェックサムビットを追加してエラーを検出できるようにする必要があります。\r\n          しかし、より困難な問題は、それらの ACK／NAK にエラーがあった場合にプロトコルがどのように復旧すべきかという点です。\r\n          この問題の難しさは、ACK や NAK が破損していた場合、送信側が直前に送信したデータが正しく受信されたかどうかを判断できないことにあります。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 3つの対応案 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Consider three possibilities for handling corrupted ACKs or NAKs:\r\n        </p>\r\n        <p>\r\n          • For the first possibility, consider what a human might do in the message-dictation\r\n          scenario. If the speaker didn’t understand the “OK” or “Please repeat that” reply\r\n          from the receiver, the speaker would probably ask, “What did you say?” (thus\r\n          introducing a new type of sender-to-receiver packet to our protocol). The receiver\r\n          would then repeat the reply. But what if the speaker’s “What did you say?” is corrupted?\r\n          The receiver, having no idea whether the garbled sentence was part of the\r\n          dictation or a request to repeat the last reply, would probably then respond with\r\n          “What did you say?” And then, of course, that response might be garbled. Clearly,\r\n          we’re heading down a difficult path.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          ACK／NAK が破損した場合の対処法として、以下の3つの可能性が考えられます。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          • 1つ目の方法は、人間の会話を例に考えるものです。\r\n          たとえば、スピーカーが「OK」や「もう一度言ってください」という返答をうまく聞き取れなかった場合、\r\n          「今なんて言いましたか？」と聞き返すでしょう。\r\n          これにより、プロトコルに新たな「スピーカー→リスナー」方向のパケット種別を追加することになります。\r\n          しかし、「今なんて？」というパケットが破損した場合、リスナーはその文が元の内容なのか再送要求なのか判断できません。\r\n          その結果、リスナーも「今なんて？」と返してしまい、その返答も破損する可能性があります。\r\n          このように、混乱は連鎖的に深まっていきます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 対応案2 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          • A second alternative is to add enough checksum bits to allow the sender not only\r\n          to detect, but also to recover from, bit errors. This solves the immediate problem\r\n          for a channel that can corrupt packets but not lose them.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          • 2つ目の方法は、チェックサムビットを十分に追加して、送信側がビット誤りを検出するだけでなく、\r\n          それを自力で訂正できるようにすることです。\r\n          これは、パケットが破損する可能性があるが、喪失しないチャネルであれば、当面の問題を解決できます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 対応案3 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          • A third approach is for the sender simply to resend the current data packet when\r\n          it receives a garbled ACK or NAK packet. This approach, however, introduces\r\n          duplicate packets into the sender-to-receiver channel.\r\n        </p>\r\n        <p>\r\n          The fundamental difficulty\r\n          with duplicate packets is that the receiver doesn’t know whether the ACK\r\n          or NAK it last sent was received correctly at the sender. Thus, it cannot know a\r\n          priori whether an arriving packet contains new data or is a retransmission!\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          • 3つ目の方法は、送信側が破損した ACK または NAK を受け取った場合に、\r\n          単純に現在のデータパケットを再送するというものです。\r\n          ただし、この方法では「重複パケット」がチャネル内に発生します。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          重複パケットの根本的な問題は、\r\n          受信側が自分の送った ACK／NAK が送信側に正しく届いたかどうかを把握できないことです。\r\n          したがって、受信したパケットが新しいデータなのか、再送されたものなのかを事前に判断できません。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- シーケンス番号による解決策 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          A simple solution to this new problem (and one adopted in almost all existing\r\n          data transfer protocols, including TCP) is to add a new field to the data packet\r\n          and have the sender number its data packets by putting a sequence number into\r\n          this field.\r\n        </p>\r\n        <p>\r\n          The receiver then need only check this sequence number to determine\r\n          whether or not the received packet is a retransmission.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          このような問題に対する簡単な解決策（そして実際にほぼすべてのデータ転送プロトコルで採用されている方法、たとえば TCP）は、\r\n          データパケットに新しいフィールドを追加して、送信側がそれぞれのパケットにシーケンス番号を付けることです。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          受信側はこのシーケンス番号をチェックするだけで、パケットが新しいものか再送されたものかを判断できます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 1ビットの例 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          For this simple case of a stop-and-wait protocol, a 1-bit sequence number will suffice,\r\n          since it will allow the receiver to know whether the sender is resending the previously\r\n          transmitted packet (the sequence number of the received packet has the same sequence\r\n          number as the most recently received packet) or a new packet (the sequence number changes).\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          ストップアンドウェイトプロトコルのような単純な場合には、\r\n          1ビットのシーケンス番号で十分です。\r\n          なぜなら、受信側はそのビット値が直前に受け取ったパケットと同じか異なるかを見て、\r\n          パケットが新しいものか再送なのかを判別できるからです。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- ACK/NAKには番号不要 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Since we are currently assuming a channel\r\n          that does not lose packets, ACK and NAK packets do not themselves need to indicate\r\n          the sequence number of the packet they are acknowledging.\r\n        </p>\r\n        <p>\r\n          The sender knows that a\r\n          received ACK or NAK packet (whether garbled or not) was generated in response to\r\n          its most recently transmitted data packet.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          現時点では、チャネルがパケットを喪失しないという仮定を置いているため、\r\n          ACK および NAK パケットには、対応するパケットのシーケンス番号を含める必要はありません。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          送信側は、自分が直前に送信したデータパケットに対する応答として\r\n          ACK／NAK（たとえそれが破損していたとしても）が返されたのだと把握できるからです。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n   <!-- 段落1 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Figures 3.11 and 3.12 show the FSM description for rdt2.1, our fixed version\r\n          of rdt2.0. The rdt2.1 sender and receiver FSMs each now have twice as many\r\n          states as before. This is because the protocol state must now reflect whether the\r\n          packet currently being sent (by the sender) or expected (at the receiver) should\r\n          have a sequence number of 0 or 1.\r\n        </p>\r\n        <p>\r\n          Note that the actions in those states where a 0-numbered packet is being sent\r\n          or expected are mirror images of those where a 1-numbered packet is being sent\r\n          or expected; the only differences have to do with the handling of the sequence number.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          図3.11と図3.12は、rdt2.0を修正したプロトコルであるrdt2.1のFSMを示しています。\r\n          rdt2.1では、送信側と受信側それぞれのFSMが以前の2倍の状態を持っています。\r\n          これは、送信中または受信予定のパケットにシーケンス番号0または1を付ける必要があるためです。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          シーケンス番号が0のパケットに関する状態での処理は、\r\n          シーケンス番号が1のパケットに関する処理の鏡像となっており、\r\n          違いはシーケンス番号の扱いのみにあります。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 図3.11 -->\r\n    <div class=\"text-center my-4\">\r\n      <img :src=\"imgRdt21Sender\" alt=\"Figure 3.11 - rdt2.1 sender\" class=\"img-fluid rounded border\" />\r\n      <p class=\"text-muted mt-2 mb-0\">Figure 3.11 — rdt2.1 sender</p>\r\n      <p class=\"text-muted\">図3.11 — rdt2.1 送信側</p>\r\n    </div>\r\n\r\n    <!-- 図3.12 -->\r\n    <div class=\"text-center my-4\">\r\n      <img :src=\"imgRdt21Receiver\" alt=\"Figure 3.12 - rdt2.1 receiver\" class=\"img-fluid rounded border\" />\r\n      <p class=\"text-muted mt-2 mb-0\">Figure 3.12 — rdt2.1 receiver</p>\r\n      <p class=\"text-muted\">図3.12 — rdt2.1 受信側</p>\r\n    </div>\r\n\r\n    <!-- 段落2 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Protocol rdt2.1 uses both positive and negative acknowledgments from the\r\n          receiver to the sender. When an out-of-order packet is received, the receiver sends\r\n          a positive acknowledgment for the packet it has received. When a corrupted packet\r\n          is received, the receiver sends a negative acknowledgment.\r\n        </p>\r\n        <p>\r\n          We can accomplish the same effect as a NAK if, instead of sending a NAK, we send\r\n          an ACK for the last correctly received packet. A sender that receives two ACKs\r\n          for the same packet (that is, receives duplicate ACKs) knows that the receiver did\r\n          not correctly receive the packet following the packet that is being ACKed twice.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          rdt2.1 プロトコルでは、受信側から送信側へACK（肯定応答）とNAK（否定応答）の両方を送信します。\r\n          順番が異なるパケットを受信した場合、受信側はそれを受け取ったというACKを送信します。\r\n          破損していた場合はNAKを返します。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          NAKの代わりに、最後に正しく受信したパケットに対するACKを再送することで、\r\n          同様の効果を得ることができます。送信側が同じパケットに対して2つのACK（重複ACK）を受け取った場合、\r\n          その後のパケットが正しく受信されなかったことがわかります。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落3 + 図3.13 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Our NAK-free reliable data transfer protocol for a channel with bit errors is rdt2.2,\r\n          shown in Figures 3.13 and 3.14. One subtle change between rdt2.1 and rdt2.2 is that\r\n          the receiver must now include the sequence number of the packet being acknowledged\r\n          by an ACK message.\r\n        </p>\r\n        <p>\r\n          This is done by including the ACK, 0 or ACK, 1 argument in make_pkt() in the receiver FSM,\r\n          and the sender must now check the sequence number of the packet being acknowledged by a\r\n          received ACK message. This is done by including the 0 or 1 argument in isACK() in the sender FSM.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          ビットエラーのあるチャネルに対してNAKを使わずに信頼性のある転送を実現するプロトコルが、\r\n          図3.13および図3.14に示されているrdt2.2です。\r\n          rdt2.1とrdt2.2の重要な違いは、ACKパケットに対応するシーケンス番号を含める点です。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          これは受信側のFSMにおいて make_pkt() に ACK, 0 または ACK, 1 を引数として渡すことで行われ、\r\n          送信側のFSMでは isACK() に 0 または 1 を渡してACKのシーケンス番号を確認することで処理されます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 図3.13 -->\r\n    <div class=\"text-center my-4\">\r\n      <img :src=\"imgRdt22Sender\" alt=\"Figure 3.13 - rdt2.2 sender\" class=\"img-fluid rounded border\" />\r\n      <p class=\"text-muted mt-2 mb-0\">Figure 3.13 — rdt2.2 sender</p>\r\n      <p class=\"text-muted\">図3.13 — rdt2.2 送信側</p>\r\n    </div>\r\n\r\n    <!-- 図3.14 -->\r\n    <div class=\"text-center my-4\">\r\n      <img :src=\"imgRdt22Receiver\" alt=\"Figure 3.14 - rdt2.2 receiver\" class=\"img-fluid rounded border\" />\r\n      <p class=\"text-muted mt-2 mb-0\">Figure 3.14 — rdt2.2 receiver</p>\r\n      <p class=\"text-muted\">図3.14 — rdt2.2 受信側</p>\r\n    </div>\r\n    \r\n\r\n        <!-- 中タイトル -->\r\n    <div class=\"row mb-4\">\r\n      <div class=\"col-12\">\r\n        <p class=\"fw-bold\" style=\"color: #004085;\">\r\n          Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落1 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Suppose now that in addition to corrupting bits, the underlying channel can lose\r\n          packets as well, a not-uncommon event in today’s computer networks (including\r\n          the Internet). Two additional concerns must now be addressed by the protocol: how\r\n          to detect packet loss and what to do when packet loss occurs.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          ここで、ビットの破損に加えて、下位チャネルがパケットを喪失する可能性があると仮定します。\r\n          これは、今日のコンピュータネットワーク（インターネットを含む）では珍しくありません。\r\n          この場合、プロトコルはさらに2つの問題、すなわち「パケット損失の検出方法」と「損失時の対処方法」に対処しなければなりません。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落2 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          The use of checksumming, sequence numbers, ACK packets, and retransmissions—\r\n          the techniques already developed in rdt2.2—will allow us to answer the latter concern.\r\n          Handling the first concern will require adding a new protocol mechanism.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          チェックサム、シーケンス番号、ACKパケット、および再送といった、\r\n          rdt2.2 ですでに導入された技術は「損失時の対処方法」に対応できます。\r\n          一方、「損失の検出方法」には新しいプロトコル機構の追加が必要になります。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落3 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          There are many possible approaches toward dealing with packet loss (several\r\n          more of which are explored in the exercises at the end of the chapter).\r\n          Here, we’ll put the burden of detecting and recovering from lost packets on the sender.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          パケット損失への対処法には多くのアプローチがあり、\r\n          いくつかは章末の演習でも紹介されています。\r\n          ここでは、損失の検出と回復の責任を送信側に課す方法を採用します。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落4 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Suppose that the sender transmits a data packet and either that packet,\r\n          or the receiver’s ACK of that packet, gets lost. In either case, no reply is\r\n          forthcoming at the sender from the receiver. If the sender is willing to wait long\r\n          enough so that it is certain that a packet has been lost, it can simply retransmit\r\n          the data packet. You should convince yourself that this protocol does indeed work.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          送信者がデータパケットを送信し、そのパケット自体あるいは受信者からのACKが失われるとします。\r\n          いずれの場合も、送信者は受信者からの返信を受け取れません。\r\n          もし送信者が「パケットが失われた」と確信できるまで十分に待てるなら、\r\n          単にそのパケットを再送すればよいのです。このプロトコルが機能することを自分で納得してみてください。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落5 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          But how long must the sender wait to be certain that something has been lost?\r\n          The sender must clearly wait at least as long as a round-trip delay between the sender\r\n          and receiver (which may include buffering at intermediate routers) plus whatever\r\n          amount of time is needed to process a packet at the receiver.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          しかし、何かが失われたと確信するまで送信者はどのくらい待つ必要があるでしょうか？\r\n          少なくとも、送信者と受信者間の往復遅延（中間ルータでのバッファリング時間を含む）と\r\n          受信側でのパケット処理時間の合計より長く待つ必要があります。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落6 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          In many networks, this worst-case maximum delay is very difficult even to estimate,\r\n          much less know with certainty. Moreover, the protocol should ideally recover from\r\n          packet loss as soon as possible; waiting for a worst-case delay could mean a long wait\r\n          until error recovery is initiated.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          多くのネットワークでは、この最悪の場合の最大遅延は推定するのさえ難しく、\r\n          正確に知ることなど到底できません。\r\n          さらに、プロトコルは理想的にはできるだけ早く損失から回復すべきであり、\r\n          最悪の遅延を待つことはエラー回復の開始が大幅に遅れることを意味します。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落7 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          The approach thus adopted in practice is for the sender to judiciously choose a time value\r\n          such that packet loss is likely, although not guaranteed, to have happened.\r\n          If an ACK is not received within this time, the packet is retransmitted.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          そのため、実際に採用されているアプローチでは、送信者がある程度の時間を\r\n          賢明に選び、その時間内にACKが受け取れなければ、パケット損失が起きた可能性が高いと判断して再送します。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落8 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Note that if a packet experiences a particularly large delay,\r\n          the sender may retransmit the packet even though neither the data packet nor its ACK have been lost.\r\n          This introduces the possibility of duplicate data packets in the sender-to-receiver channel.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          パケットが異常に大きな遅延を経験すると、\r\n          実際にはパケットもACKも失われていないにもかかわらず、送信者が再送してしまうことがあります。\r\n          これにより、送信者から受信者へのチャネルに重複したパケットが生じる可能性が出てきます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落9 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Happily, protocol rdt2.2 already has enough functionality\r\n          (that is, sequence numbers) to handle the case of duplicate packets.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          幸いなことに、プロトコルrdt2.2にはすでにシーケンス番号といった\r\n          重複パケット処理に十分な機能が備わっています。\r\n        </p>\r\n      </div>\r\n    </div>\r\n    <!-- 段落1 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          From the sender’s viewpoint, retransmission is a panacea. The sender does not\r\n          know whether a data packet was lost, an ACK was lost, or if the packet or ACK was\r\n          simply overly delayed. In all cases, the action is the same: retransmit.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          送信者の視点から見ると、再送は万能薬です。送信者には、データパケットが失われたのか、\r\n          ACKが失われたのか、あるいはどちらかが単に大きく遅延しているだけなのかを知るすべはありません。\r\n          いずれの場合でも、取るべき行動は同じです ― 再送です。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落2 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Implementing a time-based retransmission mechanism requires a countdown timer that can\r\n          interrupt the sender after a given amount of time has expired. The sender will thus\r\n          need to be able to (1) start the timer each time a packet is sent, (2) respond to a\r\n          timer interrupt, and (3) stop the timer.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          時間ベースの再送機構を実装するには、指定した時間が経過した後に送信者に割り込みをかける\r\n          カウントダウンタイマーが必要です。送信者は次の3つを実行できる必要があります：\r\n          (1) パケット（初回でも再送でも）を送るたびにタイマーを開始すること、\r\n          (2) タイマー割り込みに応じて適切な動作を行うこと、\r\n          (3) タイマーを停止すること。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 段落3 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Figure 3.15 shows the sender FSM for rdt3.0, a protocol that reliably transfers\r\n          data over a channel that can corrupt or lose packets; in the homework problems, you’ll\r\n          be asked to provide the receiver FSM for rdt3.0.\r\n        </p>\r\n        <p>\r\n          Figure 3.16 shows how the protocol operates with no lost or delayed packets and\r\n          how it handles lost data packets. In Figure 3.16, time moves forward from top to bottom.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          図3.15は、パケットの破損や喪失が起こり得るチャネル上でデータを確実に転送するプロトコル\r\n          rdt3.0の送信側FSMを示しています。rdt3.0の受信側FSMは、章末の課題で問われます。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          図3.16は、パケットの喪失や遅延がない場合と、データパケットが失われた場合の\r\n          プロトコルの動作を示しています。図3.16では、時間は上から下に進みます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- 図3.15: rdt3.0 sender -->\r\n    <div class=\"text-center my-4\">\r\n      <img\r\n        :src=\"imgRdt30Sender\"\r\n        alt=\"Figure 3.15 - rdt3.0 sender\"\r\n        class=\"img-fluid rounded border\"\r\n      />\r\n      <p class=\"text-muted mt-2 mb-0\">\r\n        Figure 3.15 — rdt3.0 sender\r\n      </p>\r\n      <p class=\"text-muted\">\r\n        図3.15 — rdt3.0 送信側\r\n      </p>\r\n    </div>\r\n\r\n    <!-- 図3.16: rdt3.0 operation -->\r\n    <div class=\"text-center my-4\">\r\n      <img\r\n        :src=\"imgRdt30Timeline\"\r\n        alt=\"Figure 3.16 - Operation of rdt3.0\"\r\n        class=\"img-fluid rounded border\"\r\n      />\r\n      <p class=\"text-muted mt-2 mb-0\">\r\n        Figure 3.16 — Operation of rdt3.0, the alternating-bit protocol\r\n      </p>\r\n      <p class=\"text-muted\">\r\n        図3.16 — rdt3.0 の動作（交互ビットプロトコル）\r\n      </p>\r\n    </div>\r\n\r\n    <!-- 締めの段落 -->\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Because packet sequence numbers alternate between 0 and 1, protocol\r\n          rdt3.0 is sometimes known as the alternating-bit protocol.\r\n        </p>\r\n        <p>\r\n          We have now assembled the key elements of a data transfer protocol.\r\n          Checksums, sequence numbers, timers, and ACK/NAK packets all play a crucial role.\r\n          We now have a working reliable data transfer protocol!\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          パケットのシーケンス番号が0と1の間で交互に変化するため、\r\n          プロトコルrdt3.0は「交互ビットプロトコル」とも呼ばれます。\r\n        </p>\r\n        <p class=\"text-muted\">\r\n          これで信頼性のあるデータ転送プロトコルに必要な要素がすべて揃いました。\r\n          チェックサム、シーケンス番号、タイマー、ACK/NAKパケット ― いずれも\r\n          重要な役割を果たします。信頼できるデータ転送プロトコルが完成しました！\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n  </div>\r\n</template>\r\n\r\n<script setup>\r\nimport imgUrl9 from '@/assets/lecture/lecture04/Figure_09.png';\r\nimport imgUrl10 from '@/assets/lecture/lecture04/Figure_10.png';\r\nimport imgRdt21Sender from '@/assets/lecture/lecture04/Figure_11.png'\r\nimport imgRdt21Receiver from '@/assets/lecture/lecture04/Figure_12.png'\r\nimport imgRdt22Sender from '@/assets/lecture/lecture04/Figure_13.png'\r\nimport imgRdt22Receiver from '@/assets/lecture/lecture04/Figure_14.png'\r\nimport imgRdt30Sender from '@/assets/lecture/lecture04/Figure_15.png'\r\nimport imgRdt30Timeline from '@/assets/lecture/lecture04/Figure_16.png'\r\n</script>\r\n","import script from \"./chapter03_41.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./chapter03_41.vue?vue&type=script&setup=true&lang=js\"\n\nconst __exports__ = script;\n\nexport default __exports__"],"names":["_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","src","_unref","imgUrl9","alt","class","_hoisted_4","imgUrl10","_hoisted_6","imgRdt21Sender","_hoisted_8","imgRdt21Receiver","_hoisted_10","imgRdt22Sender","_hoisted_12","imgRdt22Receiver","_hoisted_14","imgRdt30Sender","_hoisted_16","imgRdt30Timeline","__exports__"],"sourceRoot":""}