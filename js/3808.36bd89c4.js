"use strict";(self["webpackChunkstudy_site"]=self["webpackChunkstudy_site"]||[]).push([[3808],{3808:function(e,a,t){t.r(a),t.d(a,{default:function(){return v}});var n=t(6768),d=t(7806);const i={class:"container my-4"};var r={__name:"chapter15_31",setup(e){return(e,a)=>((0,n.uX)(),(0,n.CE)("div",i,a[0]||(a[0]=[(0,n.Fv)('<h3 class="mb-4" data-v-14cb966e>3(a) Dijkstra – Start und Initialisierung</h3><div class="border rounded p-3 bg-light mb-4" data-v-14cb966e><p data-v-14cb966e><strong data-v-14cb966e>Aufgabe:</strong><br data-v-14cb966e> Wie startet der Algorithmus und wie wird das Basiskantengewicht berechnet?<br data-v-14cb966e> (Hinweis: Der Begriff „Basiskantengewicht“ war vermutlich nicht korrekt formuliert.) </p><hr data-v-14cb966e><p data-v-14cb966e><strong data-v-14cb966e>問題:</strong><br data-v-14cb966e> Dijkstraアルゴリズムはどのように開始され、初期の重み（基準エッジの重み？）はどのように決定されるか？<br data-v-14cb966e> （※「Basiskantengewicht」は誤った表現だった可能性あり） </p></div><div class="row" data-v-14cb966e><div class="col-md-6" data-v-14cb966e><h5 data-v-14cb966e>Antwort (Deutsch)</h5><p data-v-14cb966e> Der Dijkstra-Algorithmus startet bei einem gegebenen Startknoten (z.B. A) und setzt dessen Distanz auf 0. Alle anderen Knoten erhalten zunächst den Wert ∞ (unendlich) als vorläufige Distanz. </p><p data-v-14cb966e> Dann prüft man alle direkten Nachbarn des Startknotens. Die Kosten (Kanten­gewichte) zu diesen Nachbarn werden als vorläufige Distanzen gesetzt. Diese stammen direkt aus der gegebenen Topologie – es ist keine spezielle Berechnung notwendig. </p><p data-v-14cb966e> Danach wird iterativ der Knoten mit der kleinsten bekannten Distanz ausgewählt und alle seine Nachbarn werden mithilfe der Formel<br data-v-14cb966e><code data-v-14cb966e>D(v) = min(D(v), D(w) + c(w,v))</code><br data-v-14cb966e> aktualisiert („Relaxierung“). </p></div><div class="col-md-6" data-v-14cb966e><h5 data-v-14cb966e>解答（日本語）</h5><p data-v-14cb966e> Dijkstra アルゴリズムは、出発ノード（例：A）から開始し、そのノードの距離を 0 に設定します。 他のすべてのノードの距離は初期状態として無限大（∞）とされます。 </p><p data-v-14cb966e> 次に、開始ノードに直接接続された隣接ノードを確認し、そのリンクのコストを初期距離として設定します。 この時点でのコストは既知のもので、計算というよりも与えられた値の代入です。 </p><p data-v-14cb966e> その後、未確定ノードの中から最小距離のノードを選び、そのノードの隣接ノードに対して <br data-v-14cb966e><code data-v-14cb966e>D(v) = min(D(v), D(w) + c(w,v))</code><br data-v-14cb966e> を用いて距離を更新します（これを「緩和処理」またはリラクゼーションと呼びます）。 </p></div></div><div class="text-center my-4" data-v-14cb966e><img src="'+d+'" alt="Dijkstra Beispielgraph" class="img-fluid rounded border" data-v-14cb966e><p class="text-muted mt-2" data-v-14cb966e>図 3.3 — Dijkstraアルゴリズムの初期ステップ</p></div><div class="row mt-4" data-v-14cb966e><div class="col-md-6" data-v-14cb966e><h5 data-v-14cb966e>Erklärung (Deutsch)</h5><p data-v-14cb966e> In Zeile 2–6 wird die Initialisierung vorgenommen: Nur der Startknoten ist im Set <code data-v-14cb966e>N′</code>, alle anderen bekommen initiale Distanzwerte. In der ersten Runde werden nur direkte Nachbarn betrachtet. Die sogenannten „Kantengewichte“ sind hier einfach die gegebenen Verbindungskosten. </p></div><div class="col-md-6" data-v-14cb966e><h5 data-v-14cb966e>解説（日本語）</h5><p data-v-14cb966e> アルゴリズムの2〜6行目では初期化を行い、スタートノードのみが探索済み集合に追加されます。 初期コストは、直接接続されているノードとのリンクコストに基づいて設定されます。 これが「初期エッジ重み」の意味で、特に式で導くのではなく、図から与えられる値です。 </p></div></div>',5)])))}},s=t(1241);const c=(0,s.A)(r,[["__scopeId","data-v-14cb966e"]]);var v=c},7806:function(e,a,t){e.exports=t.p+"img/Figure_0303.1950f60d.png"}}]);
//# sourceMappingURL=3808.36bd89c4.js.map