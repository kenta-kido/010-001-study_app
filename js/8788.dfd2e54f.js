"use strict";(self["webpackChunkstudy_site"]=self["webpackChunkstudy_site"]||[]).push([[8788],{4446:function(e,d,a){a.r(d),a.d(d,{default:function(){return k}});var t=a(6768),n=a(144),i=a.p+"img/Figure_0308.e7e3d694.png",s=a.p+"img/Figure_0309.b33be3f5.png",r=a.p+"img/Figure_0310.4f8dab41.png";const l={class:"container my-4"},v={class:"text-center mb-4"},o=["src"],g={class:"text-center mb-4"},u=["src"],h={class:"text-center mb-4"},c=["src"];var p={__name:"chapter15_31_ex",setup(e){return(e,d)=>((0,t.uX)(),(0,t.CE)("div",l,[d[3]||(d[3]=(0,t.Fv)('<h3 class="mb-4" data-v-23dd948e>6. Link-State Routing – Vertiefungsthemen</h3><div class="border rounded p-3 bg-light mb-4" data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>Thema 6-1:</strong><br data-v-23dd948e> Wie entsteht aus Dijkstra ein Forwarding Table? </p><hr data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>テーマ 6-1:</strong><br data-v-23dd948e> Dijkstraアルゴリズムから転送表（Forwarding Table）はどのように作られるか？ </p></div><div data-v-23dd948e><div class="row" data-v-23dd948e><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>Erklärung (Deutsch)</h5><p data-v-23dd948e> Dijkstra berechnet die kürzesten Wege zu allen Zielen. Für den Forwarding Table braucht man aber nur die nächste Station (Next Hop). Daher verfolgt man vom Ziel aus rückwärts den Pfad zum Startknoten und notiert den ersten Link. </p><p data-v-23dd948e> Für jeden Zielknoten wird also ermittelt, über welchen Nachbarn das erste Paket gehen muss. So entsteht die <strong data-v-23dd948e>Next-Hop-Tabelle</strong>, die im Router als Forwarding Table gespeichert wird. </p></div><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>解説（日本語）</h5><p data-v-23dd948e> Dijkstraアルゴリズムでは、自ノードからすべての宛先ノードまでの最短経路を計算します。 ただし、実際のパケット転送に必要なのは、「次に送るべき隣接ノード（next hop）」だけです。 </p><p data-v-23dd948e> そのため、最短経路を各宛先から逆方向にたどり、出発点（自ノード）に戻る経路上の最初のリンクを記録します。 これにより、各宛先に対してどの隣接ノードに送るべきかがわかり、<strong data-v-23dd948e>転送表（Forwarding Table）</strong>が作成されます。 </p></div></div></div><div class="border rounded p-3 bg-light mb-4" data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>Thema 6-2:</strong><br data-v-23dd948e> Wie wählt man bei mehreren gleichwertigen Pfaden? </p></div><div data-v-23dd948e><hr data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>テーマ 6-2:</strong><br data-v-23dd948e> 同じコストの複数経路がある場合、どのように選択されるのか？ </p><div class="row" data-v-23dd948e><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>Erklärung (Deutsch)</h5><p data-v-23dd948e> Wenn zwei oder mehr Pfade die gleiche Kosten haben, spricht man von einem „Tie“. Der Dijkstra-Algorithmus selbst trifft dann eine Wahl nach Implementierung: alphabetische Reihenfolge, Portnummer oder Zufall. </p><p data-v-23dd948e> Diese Wahl beeinflusst den Traffic-Fluss und kann bei kleinen Änderungen große Effekte haben. Manche Systeme nutzen Load Balancing oder Equal-Cost Multipath (ECMP), um mehrere Pfade gleichzeitig zu nutzen. </p></div><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>解説（日本語）</h5><p data-v-23dd948e> 同じコストの複数の経路が存在する場合、これを「タイ（tie）」と呼びます。 Dijkstraアルゴリズム自体は、その中から1つを選択しますが、選び方は実装に依存します。たとえば、名前順・ポート番号順・ランダムなどです。 </p><p data-v-23dd948e> この選択は通信経路に大きな影響を与える可能性があり、場合によってはEqual-Cost Multipath（ECMP）や 負荷分散を用いて複数の経路を同時に使用する方法もあります。 </p></div></div></div><div class="border rounded p-3 bg-light mb-4" data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>Thema 6-3:</strong><br data-v-23dd948e> Wie effizient ist Dijkstra und wie kann man ihn verbessern? </p></div><div data-v-23dd948e><hr data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>テーマ 6-3:</strong><br data-v-23dd948e> Dijkstraアルゴリズムの計算効率とその改善方法について </p><div class="row" data-v-23dd948e><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>Erklärung (Deutsch)</h5><p data-v-23dd948e> Die naive Implementierung von Dijkstra hat eine Komplexität von O(n<sup data-v-23dd948e>2</sup>). Bei vielen Knoten wird das langsam. Nutzt man einen Min-Heap (Priority Queue), kann man die Laufzeit auf O(n log<sub data-v-23dd948e>n</sub> + E log<sub data-v-23dd948e>n</sub>) senken. </p><p data-v-23dd948e> Moderne Implementierungen (z. B. in OSPF) verwenden binäre Heaps oder Fibonacci-Heaps, um Performance bei großen Netzen zu verbessern. </p></div><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>解説（日本語）</h5><p data-v-23dd948e> Dijkstraアルゴリズムの単純な実装では、すべてのノードに対して距離を比較するため、 計算量はO(n<sup data-v-23dd948e>2</sup>)となり、大規模ネットワークでは遅くなります。 </p><p data-v-23dd948e> これを改善するために、優先度付きキュー（Min-Heapなど）を使って 最小コストのノードを効率的に取り出すことで、O(n log<sub data-v-23dd948e>n</sub> + E log<sub data-v-23dd948e>n</sub>)に高速化できます。 </p><p data-v-23dd948e> 実際のOSPFなどでは、バイナリヒープやフィボナッチヒープを使用して処理性能を高めています。 </p></div></div></div><div class="border rounded p-3 bg-light mb-4" data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>Thema 6-4:</strong><br data-v-23dd948e> Was ist das Oscillation-Problem bei dynamischen Metriken? </p></div><div data-v-23dd948e><hr data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>テーマ 6-4:</strong><br data-v-23dd948e> 動的メトリックにおけるOscillation（経路の揺れ）問題とは？ </p><div class="row" data-v-23dd948e><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>Erklärung (Deutsch)</h5><p data-v-23dd948e> Wenn sich Metriken wie Delay oder Load schnell ändern, können Router sich gegenseitig beeinflussen und ständig die Routen wechseln. Dies nennt man Oscillation. </p><p data-v-23dd948e> Beispiel: Zwei Router wechseln immer wieder zwischen zwei Wegen, weil jeder denkt, der andere Weg sei kürzer. Die Routen „springen“ ständig hin und her. </p><p data-v-23dd948e> Lösung: Hysterese, Schwellenwerte oder Stabilitätsfilter, die nur echte Änderungen akzeptieren. </p></div><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>解説（日本語）</h5><p data-v-23dd948e> 遅延やトラフィック量などのメトリックが頻繁に変動する環境では、 ルーターが経路を頻繁に切り替えすぎて不安定になることがあります。これを「Oscillation（経路の揺れ）」と呼びます。 </p><p data-v-23dd948e> 例えば、2台のルーターが「A経由の方が速い」「いやB経由の方が速い」と交互に判断を変えることで、 経路が何度も切り替わり、パケットの安定した転送ができなくなります。 </p><p data-v-23dd948e> この問題を防ぐには、一定以上の変化がない限り経路を変えない「ヒステリシス」や、 しきい値による制御、安定化フィルターの導入が効果的です。 </p></div></div></div><div class="border rounded p-3 bg-light mb-4" data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>Thema 6-4 (Ergänzung):</strong><br data-v-23dd948e> Wie entsteht Routing-Oscillation durch lastabhängige Linkkosten? </p><hr data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>テーマ 6-4（補足）:</strong><br data-v-23dd948e> 輻輳や負荷に応じたリンクコストにより経路が「振動」してしまうのはなぜか？ </p></div>',10)),(0,t.Lk)("div",v,[(0,t.Lk)("img",{src:(0,n.R1)(i),alt:"Initial routing state (Figure 5.5a)",class:"img-fluid rounded border"},null,8,o),d[0]||(d[0]=(0,t.Lk)("p",{class:"text-muted mt-2"},"Figure 5.5(a): 初期状態 – 全ルーターが反時計回り経路を選択",-1))]),d[4]||(d[4]=(0,t.Fv)('<div class="row mb-4" data-v-23dd948e><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>Erklärung (Deutsch)</h5><p data-v-23dd948e> Wenn Linkkosten vom Datenverkehr abhängen, können Router bei jeder Ausführung des LS-Algorithmus andere Routen wählen. Das führt zu einem <strong data-v-23dd948e>instabilen Routing-Verhalten</strong>. </p><p data-v-23dd948e> Im Beispiel sendet jeder Knoten Verkehr zu w. Anfangs ist der Weg gegen den Uhrzeigersinn (counterclockwise) am günstigsten. </p><p data-v-23dd948e> Doch nachdem y den Algorithmus erneut ausführt, erkennt es, dass der <strong data-v-23dd948e>Uhrzeigersinn-Pfad</strong> kürzer geworden ist (da dort aktuell weniger Last ist). Es wechselt die Route – und bald folgen x und z. </p><p data-v-23dd948e> Doch beim nächsten Durchlauf ist der neue Weg überlastet, der vorherige Weg wieder günstiger. Alle Router schalten zurück – und der Zyklus beginnt erneut: eine <strong data-v-23dd948e>Routing-Oszillation</strong>. </p></div><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>解説（日本語）</h5><p data-v-23dd948e> リンクのコストがそのリンクを流れる<strong data-v-23dd948e>トラフィック量に応じて変化</strong>する場合、 経路が「変動」して安定しないことがあります。これが Oscillation（振動）問題です。 </p><p data-v-23dd948e> 図5.5(a)では、全ノードが w に向けてパケットを反時計回り経路で送っています。 </p><p data-v-23dd948e> ところが、次のアルゴリズム実行時に y が時計回り経路の方がコストが小さいと判断し、 それを選びます。やがて x, z もそれに追随します。 </p><p data-v-23dd948e> しかし、今度はそちらのルートが混雑し、もとのルートの方が空いてくるため、 結果的にまた反時計回りに戻ってしまいます。これが経路の「振動」です。 </p></div></div>',1)),(0,t.Lk)("div",g,[(0,t.Lk)("img",{src:(0,n.R1)(s),alt:"Routing oscillation - clockwise and counterclockwise shift",class:"img-fluid rounded border"},null,8,u),d[1]||(d[1]=(0,t.Lk)("p",{class:"text-muted mt-2"},"Figure 5.5(b)–(c): 経路の切り替え：時計回り → 反時計回りへ",-1))]),d[5]||(d[5]=(0,t.Fv)('<div class="row mb-4" data-v-23dd948e><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>Erklärung: Gegenmaßnahmen (Deutsch)</h5><p data-v-23dd948e> Um solche Oszillationen zu vermeiden, kann man Folgendes tun: </p><ul data-v-23dd948e><li data-v-23dd948e>Linkkosten sollten nicht vom aktuellen Traffic abhängen</li><li data-v-23dd948e>Nicht alle Router sollten gleichzeitig den LS-Algorithmus starten</li><li data-v-23dd948e>Man kann zufällige Verzögerungen beim Senden von Link-State-Advertisments einführen</li></ul><p data-v-23dd948e> Diese Maßnahmen helfen, das Phänomen der Selbst-Synchronisation zu vermeiden, das durch gleichzeitige Entscheidungen aller Router entsteht. </p></div><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>解説：対策（日本語）</h5><p data-v-23dd948e> このような経路振動を防ぐには、以下のような工夫が有効です： </p><ul data-v-23dd948e><li data-v-23dd948e>リンクのコストをトラフィック量に依存させない</li><li data-v-23dd948e>すべてのルーターが同時にLSアルゴリズムを実行しない</li><li data-v-23dd948e>各ルーターがリンク状態情報の送信タイミングをランダムにする</li></ul><p data-v-23dd948e> 特に「自己同期（self-synchronization）」の問題を避けるためには、 各ルーターがランダムなタイミングで動作するように設計するのが効果的です。 </p></div></div>',1)),(0,t.Lk)("div",h,[(0,t.Lk)("img",{src:(0,n.R1)(r),alt:"Final state - randomization helps prevent oscillation",class:"img-fluid rounded border"},null,8,c),d[2]||(d[2]=(0,t.Lk)("p",{class:"text-muted mt-2"},"Figure 5.5(d): 全ルーターが再び時計回り経路を選択 – 振動の繰り返し",-1))]),d[6]||(d[6]=(0,t.Fv)('<div class="border rounded p-3 bg-light mb-4" data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>Thema 6-4 (Vertiefung):</strong><br data-v-23dd948e> Wie lassen sich Routing-Oszillationen im LS-Algorithmus vermeiden? </p><hr data-v-23dd948e><p data-v-23dd948e><strong data-v-23dd948e>テーマ 6-4（発展）:</strong><br data-v-23dd948e> Link-Stateルーティングで経路振動を防ぐにはどうすればよいか？ </p></div><div class="row mb-4" data-v-23dd948e><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>Erklärung (Deutsch)</h5><p data-v-23dd948e> Routing-Oszillationen entstehen häufig, wenn Linkkosten von aktueller Last abhängen und alle Router gleichzeitig den LS-Algorithmus ausführen. Das führt zu synchronen, instabilen Pfadwechseln. </p><p data-v-23dd948e> Es gibt mehrere Gegenmaßnahmen: </p><ul data-v-23dd948e><li data-v-23dd948e><strong data-v-23dd948e>Feste Linkkosten:</strong> Man sollte Metriken wählen, die nicht direkt vom aktuellen Datenverkehr abhängen.</li><li data-v-23dd948e><strong data-v-23dd948e>Asynchrone Ausführung:</strong> Router sollten den LS-Algorithmus nicht exakt zur selben Zeit ausführen.</li><li data-v-23dd948e><strong data-v-23dd948e>Zufällige Verzögerung:</strong> Jeder Router kann die Aussendung seiner Link-State-Advertisments leicht verzögern (z.B. durch zufällige Timer).</li></ul><p data-v-23dd948e> Diese Maßnahmen verhindern <strong data-v-23dd948e>Selbstsynchronisation</strong>, ein bekanntes Phänomen, bei dem sich Router unbeabsichtigt im Takt angleichen und damit alle gleichzeitig reagieren – was Oszillation erst auslöst. </p></div><div class="col-md-6" data-v-23dd948e><h5 data-v-23dd948e>解説（日本語）</h5><p data-v-23dd948e> 経路振動（Oscillation）は、リンクコストがトラフィックに応じて変化したり、すべてのルーターが同時に経路計算を実行したりすることで発生します。 </p><p data-v-23dd948e> これを防ぐための対策には、以下のようなものがあります： </p><ul data-v-23dd948e><li data-v-23dd948e><strong data-v-23dd948e>静的なリンクコストを使用：</strong> 通信量に応じてリンクコストが変わる設計は避け、一定のメトリック（距離や帯域など）を使う。</li><li data-v-23dd948e><strong data-v-23dd948e>非同期での実行：</strong> 全ルーターが同時にアルゴリズムを走らせるのではなく、タイミングをずらす。</li><li data-v-23dd948e><strong data-v-23dd948e>リンク状態広告の送信タイミングにランダム性を持たせる：</strong> これにより「自己同期」が起きにくくなります。</li></ul><p data-v-23dd948e> 自己同期とは、各ルーターが偶然にも同じ周期でLSAを送るようになり、 ネットワーク全体で一斉にルーティングの更新が走ってしまう現象です。 このようなタイミングの一致が経路の振動を引き起こすため、ランダムな遅延を加えることで予防できます。 </p></div></div>',2))]))}},m=a(1241);const b=(0,m.A)(p,[["__scopeId","data-v-23dd948e"]]);var k=b}}]);
//# sourceMappingURL=8788.dfd2e54f.js.map