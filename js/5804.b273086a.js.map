{"version":3,"file":"js/5804.b273086a.js","mappings":"mWACEA,EAAAA,EAAAA,IA4cM,MA5cNC,EA4cM,C,otRAlNRC,EAAAA,EAAAA,IAYM,MAZNC,EAYM,EAXJD,EAAAA,EAAAA,IAIE,OAHCE,KAAKC,EAAAA,EAAAA,IAAAC,GACNC,IAAI,6DACJC,MAAM,4B,uBAERN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,wBAAuB,yFAEhC,I,aACAN,EAAAA,EAAAA,IAEI,KAFDM,MAAM,cAAa,oDAEtB,M,0xMChQF,MAAMC,GAA2B,OAAgB,EAAQ,CAAC,CAAC,YAAY,qBAEvE,O","sources":["webpack://study-site/./src/views/lecture/lecture04/chapter03/chapter03_30.vue","webpack://study-site/./src/views/lecture/lecture04/chapter03/chapter03_30.vue?0e47"],"sourcesContent":["<template>\r\n  <div class=\"container my-4\">\r\n    <h3 class=\"mb-4\">3.3 Connectionless Transport: UDP</h3>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          In this section, we’ll take a close look at UDP, how it works, and what it does.\r\n          We encourage you to refer back to Section 2.1, which includes an overview of the\r\n          UDP service model, and to Section 2.7.1, which discusses socket programming using\r\n          UDP.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          このセクションでは、UDPがどのように動作し、何を行うのかを詳しく見ていきます。2.1節にはUDPのサービスモデルの概要が、2.7.1節にはUDPを使ったソケットプログラミングについての解説がありますので、併せて参照することをお勧めします。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          To motivate our discussion about UDP, suppose you were interested in designing\r\n          a no-frills, bare-bones transport protocol. How might you go about doing this?\r\n          You might first consider using a vacuous transport protocol.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          UDPについての議論を進めるために、まずは機能を最小限に絞ったシンプルなトランスポートプロトコルを設計することを考えてみましょう。どのように設計を始めるでしょうか？まずは、中身のない空のトランスポートプロトコルを検討するかもしれません。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          In particular, on the sending side, you might consider taking the messages from the application process\r\n          and passing them directly to the network layer; and on the receiving side, you might\r\n          consider taking the messages arriving from the network layer and passing them\r\n          directly to the application process.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          たとえば、送信側ではアプリケーションプロセスから受け取ったメッセージをそのままネットワーク層へ渡し、受信側ではネットワーク層から到着したメッセージを直接アプリケーションプロセスへ渡すことを考えるかもしれません。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          But as we learned in the previous section, we have to do a little more than nothing! At the very least, the transport layer has to provide a\r\n          multiplexing/demultiplexing service in order to pass data between the network layer\r\n          and the correct application-level process.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          しかし、前のセクションで学んだように、「何もしない」では不十分です。少なくとも、トランスポート層はネットワーク層と正しいアプリケーションプロセス間でデータをやり取りするためのマルチプレクシング／デマルチプレクシング機能を提供しなければなりません。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          UDP, defined in [RFC 768], does just about as little as a transport protocol can do.\r\n          Aside from the multiplexing/demultiplexing function and some light error checking, it\r\n          adds nothing to IP.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          [RFC 768] で定義されているUDPは、トランスポートプロトコルとして可能な限り最小限の機能しか提供していません。マルチプレクシング／デマルチプレクシング機能と軽度なエラーチェック以外、IPに何も追加していないのです。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          In fact, if the application developer chooses UDP instead of TCP,\r\n          then the application is almost directly talking with IP. UDP takes messages from the\r\n          application process, attaches source and destination port number fields for the multiplexing/\r\n          demultiplexing service, adds two other small fields, and passes the resulting\r\n          segment to the network layer.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          実際、アプリケーション開発者がTCPではなくUDPを選んだ場合、アプリケーションはほぼ直接IPと通信していることになります。UDPはアプリケーションプロセスからメッセージを受け取り、マルチプレクシング／デマルチプレクシングのための送信元および宛先ポート番号を追加し、さらに2つの小さなフィールドを加えて、セグメントとしてネットワーク層に渡します。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          The network layer encapsulates the transport-layer segment\r\n          into an IP datagram and then makes a best-effort attempt to deliver the segment\r\n          to the receiving host.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          ネットワーク層はこのトランスポート層セグメントをIPデータグラムとしてカプセル化し、受信ホストへの配送をベストエフォートで試みます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          If the segment arrives at the receiving host, UDP uses the destination\r\n          port number to deliver the segment’s data to the correct application process. Note\r\n          that with UDP there is no handshaking between sending and receiving transport-layer\r\n          entities before sending a segment. For this reason, UDP is said to be connectionless.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          セグメントが受信ホストに届いた場合、UDPは宛先ポート番号を用いてセグメントのデータを適切なアプリケーションプロセスへ届けます。UDPではセグメントを送信する前に送信側と受信側の間でハンドシェイクを行わないため、UDPは「コネクションレス（接続不要）」と呼ばれています。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          DNS is an example of an application-layer protocol that typically uses UDP.\r\n          When the DNS application in a host wants to make a query, it constructs a DNS query\r\n          message and passes the message to UDP.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          DNSは、通常UDPを利用するアプリケーション層プロトコルの一例です。ホスト上のDNSアプリケーションが問い合わせを行いたいとき、それはDNSクエリメッセージを構築し、それをUDPに渡します。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          Without performing any handshaking with\r\n          the UDP entity running on the destination end system, the host-side UDP adds header\r\n          fields to the message and passes the resulting segment to the network layer.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          宛先側のUDPエンティティとハンドシェイクを行うことなく、送信側のホストはUDPヘッダフィールドをそのメッセージに追加し、生成されたセグメントをネットワーク層へ渡します。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          The network\r\n          layer encapsulates the UDP segment into a datagram and sends the datagram to\r\n          a name server. The DNS application at the querying host then waits for a reply to its\r\n          query.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          ネットワーク層はUDPセグメントをデータグラムにカプセル化し、それをネームサーバーに送信します。そして、DNSアプリケーションは応答を待ちます。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n      <div class=\"col-md-6\">\r\n        <p>\r\n          If it doesn’t receive a reply (possibly because the underlying network lost the\r\n          query or the reply), it might try resending the query, try sending the query to another\r\n          name server, or inform the invoking application that it can’t get a reply.\r\n        </p>\r\n      </div>\r\n      <div class=\"col-md-6\">\r\n        <p class=\"text-muted\">\r\n          応答が得られなかった場合（基盤ネットワークがクエリまたは応答を紛失した可能性があります）、再送信を試みたり、別のネームサーバーに送信したり、呼び出し元アプリケーションに応答が得られないことを通知したりします。\r\n        </p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Figure 3.6 lists popular Internet applications and the transport protocols that\r\n      they use. As we expect, e-mail, remote terminal access, and file transfer run over\r\n      TCP—all these applications need the reliable data transfer service of TCP.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      図3.6は、代表的なインターネットアプリケーションと、それぞれが使用するトランスポートプロトコルを示しています。予想どおり、電子メール、リモートターミナルアクセス、ファイル転送はすべてTCPを使用しており、これらのアプリケーションはいずれもTCPの信頼性のあるデータ転送サービスを必要としています。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      We learned in Chapter 2 that early versions of HTTP ran over TCP but that more recent\r\n      versions of HTTP run over UDP, providing their own error control and congestion\r\n      control (among other services) at the application layer.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      第2章で学んだように、初期のHTTPはTCP上で動作していましたが、最近のHTTPのバージョンではUDPを使用し、アプリケーション層で独自のエラー制御や輻輳制御（およびその他のサービス）を提供しています。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Nevertheless, many important applications run over UDP rather than TCP. For example,\r\n      UDP is used to carry network management (SNMP; see Section 5.7) data. UDP is preferred\r\n      to TCP in this case, since network management applications must often run when\r\n      the network is in a stressed state—precisely when reliable, congestion-controlled\r\n      data transfer is difficult to achieve.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      それでも、重要なアプリケーションの多くはTCPではなくUDPを使用しています。たとえば、UDPはネットワーク管理（SNMP、5.7節参照）データの転送に使われています。ネットワーク管理アプリケーションは、ネットワークが過負荷状態にあるときでも動作する必要があるため、信頼性があり輻輳制御された通信が困難なこのような状況ではUDPの方が適しています。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Also, as we mentioned earlier, DNS runs over UDP, thereby avoiding\r\n      TCP’s connection-establishment delays.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      また、前述の通り、DNSはUDP上で動作しており、TCPの接続確立に伴う遅延を回避しています。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"text-center my-4\">\r\n  <img\r\n    :src=\"imgUrl\"\r\n    alt=\"Figure 3.6 - Internet applications and transport protocols\"\r\n    class=\"img-fluid rounded border\"\r\n  />\r\n  <p class=\"text-muted mt-2 mb-0\">\r\n    Figure 3.6 — Popular Internet applications and their underlying transport protocols\r\n  </p>\r\n  <p class=\"text-muted\">\r\n    図3.6 — 代表的なインターネットアプリケーションとその基盤となるトランスポートプロトコル\r\n  </p>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      As shown in Figure 3.6, both UDP and TCP are sometimes used today with\r\n      multimedia applications, such as Internet phone, real-time video conferencing, and\r\n      streaming of stored audio and video.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      図3.6に示されているように、インターネット電話、リアルタイムビデオ会議、保存された音声・動画のストリーミングといったマルチメディアアプリケーションでは、UDPとTCPの両方が使われることがあります。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      All of these applications\r\n      can tolerate a small amount of packet loss, so that reliable data transfer is not\r\n      absolutely critical for the application’s success.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      これらのアプリケーションはいずれも、ある程度のパケット損失を許容できるため、信頼性のあるデータ転送がアプリケーションの成功に必須とは限りません。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Furthermore, real-time applications,\r\n      like Internet phone and video conferencing, react very poorly to TCP’s congestion\r\n      control. For these reasons, developers of multimedia applications may choose to run\r\n      their applications over UDP instead of TCP.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      さらに、インターネット電話やビデオ会議のようなリアルタイムアプリケーションは、TCPの輻輳制御に非常に弱いため、これらの理由からマルチメディアアプリケーションの開発者はTCPではなくUDPを使用することを選択する場合があります。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      When packet loss rates are low, and with some organizations blocking UDP traffic for security reasons (see Chapter 8),\r\n      TCP becomes an increasingly attractive protocol for streaming media transport.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      パケット損失率が低く、また一部の組織がセキュリティ上の理由でUDPトラフィックをブロックしている場合（第8章参照）、ストリーミングメディアの転送においてTCPの魅力が増すことになります。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Although commonly done today, running multimedia applications over UDP\r\n      needs to be done with care. As we mentioned above, UDP has no congestion control.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      今日では一般的になっていますが、UDP上でマルチメディアアプリケーションを動作させる場合には注意が必要です。前述の通り、UDPには輻輳制御がありません。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      But congestion control is needed to prevent the network from entering a congested\r\n      state in which very little useful work is done. If everyone were to start streaming\r\n      high-bit-rate video without using any congestion control, there would be so much\r\n      packet overflow at routers that very few UDP packets would successfully traverse the\r\n      source-to-destination path.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      しかし、ネットワークが過度な輻輳状態に陥るのを防ぐためには輻輳制御が不可欠です。もし誰もが輻輳制御なしに高ビットレートのビデオをストリーミングし始めた場合、ルーターでパケットがあふれ、送信元から宛先へのUDPパケットの多くが届かなくなるでしょう。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Moreover, the high loss rates induced by the uncontrolled\r\n      UDP senders would cause the TCP senders (which, as we’ll see, do decrease their\r\n      sending rates in the face of congestion) to dramatically decrease their rates.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      さらに、制御されていないUDP送信者による高い損失率は、TCP送信者（輻輳に直面すると送信レートを下げることが後述されます）に対してもレートの大幅な低下を引き起こします。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Thus, the lack of congestion control in UDP can result in high loss rates between a UDP sender\r\n      and receiver, and the crowding out of TCP sessions.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      このように、UDPに輻輳制御が存在しないことは、UDPの送信者と受信者間での高い損失率や、TCPセッションの締め出し（クラウドアウト）を引き起こす可能性があります。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Many researchers have proposed new mechanisms to force all sources, including UDP sources, to perform adaptive\r\n      congestion control.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      多くの研究者が、UDPを含むすべての送信元に適応的な輻輳制御を強制する新しい仕組みを提案しています。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Before discussing the UDP segment structure, we mention that it is possible\r\n      for an application to have reliable data transfer when using UDP.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      UDPセグメント構造を説明する前に、UDPを使用していてもアプリケーションで信頼性のあるデータ転送を実現することが可能であることを述べておきます。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      This can be done\r\n      if reliability is built into the application itself (for example, by adding acknowledgment\r\n      and retransmission mechanisms, such as those we’ll study in the next\r\n      section).\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      これは、アプリケーション自体に信頼性を持たせることで可能です。例えば、確認応答（ACK）や再送機構などを組み込むことで、次のセクションで学ぶような仕組みが実現されます。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      We mentioned earlier that the QUIC protocol implements reliability\r\n      in an application-layer protocol on top of UDP. But this is a nontrivial task that\r\n      would keep an application developer busy debugging for a long time.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      先に述べたQUICプロトコルは、UDP上のアプリケーション層プロトコルとして信頼性を実現していますが、これは決して簡単な作業ではなく、アプリケーション開発者は長い時間デバッグに費やすことになります。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row mb-3\">\r\n  <div class=\"col-md-6\">\r\n    <p>\r\n      Nevertheless,\r\n      building reliability directly into the application allows the application to “have its cake and eat it too.”\r\n      That is, application processes can communicate reliably\r\n      without being subjected to the transmission-rate constraints imposed by TCP’s\r\n      congestion-control mechanism.\r\n    </p>\r\n  </div>\r\n  <div class=\"col-md-6\">\r\n    <p class=\"text-muted\">\r\n      それでも、信頼性をアプリケーション内に実装することで、“おいしいところ取り”が可能になります。つまり、TCPの輻輳制御による送信レートの制約を受けずに、信頼性のある通信を実現できるのです。\r\n    </p>\r\n  </div>\r\n</div>\r\n\r\n  </div>\r\n</template>\r\n\r\n<script setup>\r\nimport imgUrl from '@/assets/lecture/lecture04/Figure_06.png';\r\n</script>\r\n\r\n<style scoped>\r\n.text-muted {\r\n  color: #6c757d;\r\n}\r\n</style>\r\n","import script from \"./chapter03_30.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./chapter03_30.vue?vue&type=script&setup=true&lang=js\"\n\nimport \"./chapter03_30.vue?vue&type=style&index=0&id=eb6c71e2&scoped=true&lang=css\"\n\nimport exportComponent from \"../../../../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-eb6c71e2\"]])\n\nexport default __exports__"],"names":["_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","src","_unref","imgUrl","alt","class","__exports__"],"sourceRoot":""}