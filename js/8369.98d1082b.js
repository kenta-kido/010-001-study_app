"use strict";(self["webpackChunkstudy_site"]=self["webpackChunkstudy_site"]||[]).push([[8369],{8369:function(d,a,t){t.r(a),t.d(a,{default:function(){return v}});var e=t(6768);const n={class:"container my-4"};var i={__name:"chapter15_94",setup(d){return(d,a)=>((0,e.uX)(),(0,e.CE)("div",n,a[0]||(a[0]=[(0,e.Fv)('<h3 class="mb-4" data-v-41d17f34>9(d) Wachstumsverhalten von AIMD und CUBIC</h3><div class="border rounded p-3 bg-light mb-4" data-v-41d17f34><p data-v-41d17f34><strong data-v-41d17f34>Aufgabe:</strong><br data-v-41d17f34> In den folgenden Teilaufgaben (i) und (ii) wird angenommen, dass das Übertragungsfenster den Schwellenwert <i data-v-41d17f34>W<sub data-v-41d17f34>max</sub></i> noch nicht erreicht hat. </p><p data-v-41d17f34> (i) Vergleichen Sie die Reaktionsgeschwindigkeit (d.h. die Geschwindigkeit der Änderung der Übertragungsrate) zwischen TCP-CUBIC und dem klassischen AIMD-Verfahren. </p><p data-v-41d17f34> (ii) Vergleichen Sie die typische Entwicklung der Senderate (Fenstergröße) zwischen TCP-CUBIC und AIMD. </p><hr data-v-41d17f34><p data-v-41d17f34><strong data-v-41d17f34>問題：</strong><br data-v-41d17f34> 以下の (i)、(ii) の各小問では、送信ウィンドウがしきい値 <i data-v-41d17f34>W<sub data-v-41d17f34>max</sub></i> に達していないと仮定する。 </p><p data-v-41d17f34> (i) TCP-CUBIC と従来の AIMD 手法における反応速度（転送レートの変化速度）を比較せよ。 </p><p data-v-41d17f34> (ii) TCP-CUBIC と AIMD の送信レート（ウィンドウサイズ）の典型的な成長の仕方を比較せよ。 </p></div><div class="row mt-4" data-v-41d17f34><div class="col-md-6" data-v-41d17f34><h5 data-v-41d17f34>Einordnung &amp; Begriffserklärung (Deutsch)</h5><p data-v-41d17f34> In dieser Aufgabe wird ausdrücklich gesagt, dass das Übertragungsfenster <strong data-v-41d17f34>W<sub data-v-41d17f34>max</sub></strong> noch nicht erreicht ist. Das bedeutet, dass sich CUBIC in der <strong data-v-41d17f34>konkaven Phase</strong> seines Wachstums befindet – das Fenster wächst eher langsam. </p><p data-v-41d17f34> Der Unterschied der beiden Teilaufgaben ist wie folgt: </p><ul data-v-41d17f34><li data-v-41d17f34><strong data-v-41d17f34>(i) Reaktionsgeschwindigkeit:</strong> Wie schnell ändert sich das Wachstum <em data-v-41d17f34>pro Zeiteinheit</em> in der aktuellen Phase?</li><li data-v-41d17f34><strong data-v-41d17f34>(ii) Senderate:</strong> Wie entwickelt sich die absolute Fenstergröße im Verlauf der Zeit?</li></ul><p data-v-41d17f34> Die Reaktionsgeschwindigkeit ist also die <em data-v-41d17f34>Steigung</em> der Funktion W(t), während die Senderate der <em data-v-41d17f34>Wert</em> von W(t) selbst ist. Beide hängen bei CUBIC vom Zeitabstand zum letzten Verlustereignis ab. </p></div><div class="col-md-6" data-v-41d17f34><h5 data-v-41d17f34>解説（日本語）</h5><p data-v-41d17f34> 本問では、送信ウィンドウがまだ <strong data-v-41d17f34>W<sub data-v-41d17f34>max</sub></strong> に到達していないと明示されています。これは、<strong data-v-41d17f34>CUBIC が凹型（concave）フェーズ</strong>にあることを意味し、<strong data-v-41d17f34>緩やかな増加</strong>をしている状態です。 </p><p data-v-41d17f34> 各小問の意味の違いは以下の通りです： </p><ul data-v-41d17f34><li data-v-41d17f34><strong data-v-41d17f34>(i) 反応速度：</strong> 単位時間あたりの増加量、つまり「今どのくらいのスピードでウィンドウが増えているか」（成長率）</li><li data-v-41d17f34><strong data-v-41d17f34>(ii) 送信レート：</strong> 時間の経過とともにウィンドウサイズ（cwnd）がどのように変化していくか（成長パターン）</li></ul><p data-v-41d17f34> 簡単に言えば、<strong data-v-41d17f34>反応速度</strong>は「傾き」、<strong data-v-41d17f34>送信レート</strong>は「値そのものの推移」を見ています。<br data-v-41d17f34> AIMDは常に一定の傾き、CUBICは時間とともに傾きが変わるため、前者は一定速度、後者は加速的な変化をします（ただし W<sub data-v-41d17f34>max</sub> に近づくまでは遅い）。 </p></div></div><div class="row" data-v-41d17f34><div class="col-md-6" data-v-41d17f34><h5 data-v-41d17f34>Antwort (Deutsch)</h5><p data-v-41d17f34><strong data-v-41d17f34>Voraussetzung:</strong> Da W<sub data-v-41d17f34>max</sub> noch nicht erreicht ist, befindet sich CUBIC in der <em data-v-41d17f34>konkaven Phase</em> seiner Wachstumsfunktion.</p><p data-v-41d17f34><strong data-v-41d17f34>(i) Reaktionsgeschwindigkeit:</strong></p><ul data-v-41d17f34><li data-v-41d17f34>AIMD erhöht cwnd konstant um 1 MSS（Maximum Segment Size） pro RTT → konstante, lineare Geschwindigkeit.</li><li data-v-41d17f34>CUBIC verwendet <i data-v-41d17f34>W(t) = C(t−K)³ + W<sub data-v-41d17f34>max</sub></i>, wobei die Änderungsrate <i data-v-41d17f34>dW/dt = 3C(t−K)²</i> ist.</li><li data-v-41d17f34>⇒ Zu Beginn (t = 0) ist die Reaktion schnell (3CK²), wird jedoch langsamer, je näher t an K liegt. Bei t = K ist die Geschwindigkeit null.</li></ul><div data-v-41d17f34><strong data-v-41d17f34>Ergänzung zu AIMD (Deutsch)</strong><p data-v-41d17f34> Beim klassischen AIMD-Verfahren erfolgt die additive Erhöhung der cwnd um <strong data-v-41d17f34>1 MSS pro RTT</strong>. Dies ergibt sich daraus, dass bei jeder empfangenen ACK cwnd um <code data-v-41d17f34>1/cwnd</code> MSS erhöht wird. Bei cwnd ACKs pro RTT summiert sich das genau zu 1 MSS pro RTT. </p><p data-v-41d17f34> Beim klassischen AIMD-Verfahren erfolgt die additive Erhöhung der cwnd um <strong data-v-41d17f34>1 MSS pro RTT</strong>. Dies ergibt sich daraus, dass TCP bei jedem empfangenen ACK die Fenstergröße um <code data-v-41d17f34>1 / cwnd</code> MSS erhöht. Bei cwnd ACKs pro RTT ergibt sich eine Zunahme von insgesamt <strong data-v-41d17f34>1 MSS pro RTT</strong>. </p><p data-v-41d17f34> Diese lineare Steigerung bedeutet, dass Verbindungen mit kürzerem RTT schneller wachsen, was zu <strong data-v-41d17f34>RTT-Unfairness</strong> führen kann. CUBIC adressiert dieses Problem durch ein wachstumsverhalten, das unabhängig von RTT ist. </p></div><p data-v-41d17f34><strong data-v-41d17f34>(ii) Entwicklung der Senderate:</strong></p><ul data-v-41d17f34><li data-v-41d17f34>AIMD: cwnd wächst linear mit der Zeit, unabhängig vom vorherigen Maximum.</li><li data-v-41d17f34>CUBIC: cwnd wächst nicht-linear (t³), bildet ein Plateau bei W<sub data-v-41d17f34>max</sub> und wächst danach erneut schneller (konvexes Wachstum).</li><li data-v-41d17f34>Durch die Zeit-basierte Steuerung ist CUBIC effizienter bei großen Bandbreiten und hohen RTTs.</li></ul></div><div class="col-md-6" data-v-41d17f34><h5 data-v-41d17f34>解答（日本語）</h5><p data-v-41d17f34><strong data-v-41d17f34>前提：</strong> W<sub data-v-41d17f34>max</sub> に達していないため、CUBIC は <em data-v-41d17f34>凹型フェーズ（concave region）</em> にあります。</p><p data-v-41d17f34><strong data-v-41d17f34>(i) 反応速度：</strong></p><ul data-v-41d17f34><li data-v-41d17f34>AIMD：RTT ごとに一定量（1セグメント）ずつ増加 → 常に一定の反応速度。</li><li data-v-41d17f34>CUBIC：<i data-v-41d17f34>W(t) = C(t−K)³ + W<sub data-v-41d17f34>max</sub></i> に従い、微分値 <i data-v-41d17f34>dW/dt = 3C(t−K)²</i> が反応速度を示す。</li><li data-v-41d17f34>⇒ 初期（t = 0）では <i data-v-41d17f34>3CK²</i> と速いが、時間が経って t → K に近づくと反応速度は減少し、t = K で 0 になる。</li></ul><div data-v-41d17f34><strong data-v-41d17f34>補足：AIMD の成長挙動</strong><p data-v-41d17f34> AIMD（加算的増加）では、<strong data-v-41d17f34>RTT ごとに cwnd が 1 MSS（最大セグメントサイズ）増加</strong>します。 これは TCP が 1 ACK を受け取るたびに <code data-v-41d17f34>1 / cwnd</code> MSS 分だけ cwnd を増やすためで、 1 RTT に約 cwnd 個の ACK が返ってくることで合計 1 MSS 増加します。 </p><p data-v-41d17f34> よって、これは時間あたりのウィンドウ増加率として次のように表せます： </p><p class="text-center" data-v-41d17f34><strong data-v-41d17f34>増加速度 = 1 MSS / RTT</strong></p><p data-v-41d17f34> つまり、<strong data-v-41d17f34>RTT が短いほど cwnd の成長が速くなる</strong>ため、短RTTフローが有利となり、不公平性が生じます。 CUBIC はこの課題に対応するため、RTT に依存しない時間ベースの成長モデルを採用しています。 </p><p data-v-41d17f34> このため、<strong data-v-41d17f34>RTT が短いフローほど速く増加</strong>し、結果として「RTT による不公平さ」が生まれます。 CUBIC はこの点を解消するため、RTT 非依存な時間ベース成長モデルを採用しています。 </p></div><p data-v-41d17f34><strong data-v-41d17f34>(ii) 送信レートの推移：</strong></p><ul data-v-41d17f34><li data-v-41d17f34>AIMD：時間に対して直線的にウィンドウが増加し、過去の最大値に依存しない。</li><li data-v-41d17f34>CUBIC：三次関数的に成長し、W<sub data-v-41d17f34>max</sub> に近づくと成長が鈍化（プラトー）、それを越えると再び加速的に増加（凸型）。</li><li data-v-41d17f34>RTT に依存せず、経過時間のみで増加するため、遅延が大きいネットワークでも高効率。</li></ul></div></div><div class="border rounded p-3 bg-light mb-4" data-v-41d17f34><p data-v-41d17f34><strong data-v-41d17f34>Aufgabe:</strong><br data-v-41d17f34> Beschreiben Sie die Wachstumsfunktionen von AIMD und CUBIC.<br data-v-41d17f34> Wie verläuft das Wachstum der Congestion Window (cwnd) in beiden Ansätzen (linear vs. kubisch)?<br data-v-41d17f34> Was bedeutet das für die Performance in Netzwerken mit hoher Bandbreite und Latenz? (4P) </p><hr data-v-41d17f34><p data-v-41d17f34><strong data-v-41d17f34>問題:</strong><br data-v-41d17f34> AIMD と CUBIC の成長関数を比較せよ。<br data-v-41d17f34> 各方式における輻輳ウィンドウ（cwnd）の増加はどのような形か（線形 vs. 三次関数）？<br data-v-41d17f34> それは高帯域・高遅延ネットワークにおいて性能にどのような影響を与えるか？（4点） </p></div><div class="row" data-v-41d17f34><div class="col-md-6" data-v-41d17f34><h5 data-v-41d17f34>Antwort (Deutsch)</h5><p data-v-41d17f34><strong data-v-41d17f34>AIMD:</strong></p><ul data-v-41d17f34><li data-v-41d17f34>cwnd wächst linear pro RTT (Additive Increase)</li><li data-v-41d17f34>Verlust führt zu Multiplicative Decrease (z.B. Halbierung)</li><li data-v-41d17f34>Effizient bei kleinen bis mittleren Netzen</li></ul><p data-v-41d17f34><strong data-v-41d17f34>CUBIC:</strong></p><ul data-v-41d17f34><li data-v-41d17f34>cwnd wächst gemäß kubischer Funktion: <span data-v-41d17f34>W(t) = C(t−K)³ + W<sub data-v-41d17f34>max</sub></span></li><li data-v-41d17f34>Wachstum unabhängig von RTT → besser in Hochlatenznetzen</li><li data-v-41d17f34>Schnellere Erholung und bessere Auslastung bei großer Bandbreite</li></ul><p data-v-41d17f34><strong data-v-41d17f34>Fazit:</strong> CUBIC skaliert besser in Hochgeschwindigkeitsnetzen mit hoher Latenz als AIMD.</p></div><div class="col-md-6" data-v-41d17f34><h5 data-v-41d17f34>解答（日本語）</h5><p data-v-41d17f34><strong data-v-41d17f34>AIMD：</strong></p><ul data-v-41d17f34><li data-v-41d17f34>cwnd は RTT ごとに線形に増加（加算的増加）</li><li data-v-41d17f34>損失時に乗算的に減少（例：半分）</li><li data-v-41d17f34>中小規模のネットワークでは適している</li></ul><p data-v-41d17f34><strong data-v-41d17f34>CUBIC：</strong></p><ul data-v-41d17f34><li data-v-41d17f34>cwnd は三次関数に基づいて増加：<span data-v-41d17f34>W(t) = C(t−K)³ + W<sub data-v-41d17f34>max</sub></span></li><li data-v-41d17f34>RTT に依存せず、遅延の大きい環境でも効率よく増加</li><li data-v-41d17f34>高帯域のネットワークでの利用率が高く、回復も早い</li></ul><p data-v-41d17f34><strong data-v-41d17f34>結論：</strong> CUBIC は高帯域・高遅延ネットワークにおいて AIMD よりもスケーラビリティに優れている。</p></div></div>',6)])))}},s=t(1241);const r=(0,s.A)(i,[["__scopeId","data-v-41d17f34"]]);var v=r}}]);
//# sourceMappingURL=8369.98d1082b.js.map